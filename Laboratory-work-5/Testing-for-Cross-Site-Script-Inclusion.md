# Тестування на включення міжсайтового сценарію

## Загальне

Уразливість XSSI (включення міжсайтового сценарію) дає змогу витоку конфіденційних даних через вихідні або міждоменні межі. Конфіденційні дані можуть включати дані, пов’язані з автентифікацією (стани входу, файли cookie, маркери автентифікації, ідентифікатори сеансу тощо), або персональні або конфіденційні особисті дані користувача (адреси електронної пошти, номери телефонів, дані кредитної картки, номери соціального страхування тощо). XSSI — це атака на стороні клієнта, схожа на Cross Site Request Forgery (CSRF), але має іншу мету. Якщо CSRF використовує контекст автентифікованого користувача для виконання певних дій зі зміни стану на сторінці жертви (наприклад, переказ грошей на рахунок зловмисника, зміна привілеїв, скидання пароля тощо), XSSI замість цього використовує JavaScript на стороні клієнта для витоку конфіденційних даних. з автентифікованих сеансів.

За замовчуванням веб-сайтам дозволено отримувати доступ до даних, лише якщо вони мають одне джерело. Це ключовий принцип безпеки програми, який регулюється політикою того самого джерела (визначеною RFC 6454). Походження визначається як комбінація схеми URI (HTTP або HTTPS), імені хоста та номера порту. Однак ця політика не застосовується до включень тегу HTML script. Цей виняток є необхідним, оскільки без нього веб-сайти не зможуть використовувати сторонні послуги, виконувати аналіз трафіку або використовувати рекламні платформи тощо.

Коли веб-переглядач відкриває веб-сайт із тегами script, ресурси завантажуються з перехресного домену. Ресурси потім працюють у тому ж контексті, що й сайт або браузер, що включає, що створює можливість витоку конфіденційних даних. У більшості випадків це досягається за допомогою JavaScript, однак джерело сценарію не обов’язково має бути файлом JavaScript із розширенням типу text/javascript або .js.

Уразливості старішого браузера (IE9/10) допускали витік даних через повідомлення про помилки JavaScript під час виконання, але наразі ці уразливості виправлено постачальниками, і вони вважаються менш актуальними. Встановлюючи атрибут charset тегу script, зловмисник або тестувальник може застосувати кодування UTF-16, у деяких випадках дозволяючи витік даних для інших форматів даних (наприклад, JSON). Додаткову інформацію про ці атаки див. у розділі XSSI-атаки на основі ідентифікатора.

## Цілі тестування

- Знайдіть конфіденційні дані в системі.
- Оцініть витік конфіденційних даних за допомогою різних методів.

## Як тестувати

### Збирайте дані за допомогою аутентифікованих і неаутентифікованих сеансів користувачів
Визначте, які кінцеві точки відповідають за надсилання конфіденційних даних, які параметри потрібні, а також визначте всі відповідні динамічно та статично згенеровані відповіді JavaScript за допомогою автентифікованих сеансів користувачів. Зверніть особливу увагу на конфіденційні дані, які надсилаються за допомогою JSONP. Щоб знайти динамічно згенеровані відповіді JavaScript, створіть автентифіковані та неавтентифіковані запити, а потім порівняйте їх. Якщо вони різні, це означає, що відповідь динамічна; інакше він статичний. Щоб спростити це завдання, можна використати такий інструмент, як проксі-плагін Veit Hailperin Burp. Обов’язково перевіряйте інші типи файлів на додаток до JavaScript; XSSI не обмежується лише файлами JavaScript.

### Визначте, чи може статися витік конфіденційних даних за допомогою JavaScript
Тестери повинні проаналізувати код для таких транспортних засобів на предмет витоку даних через уразливості XSSI:

1. Глобальні змінні
2. Глобальні параметри функції
3. CSV (Comma Separated Values) із крадіжкою цитат
4. Помилки виконання JavaScript
5. З’єднання прототипів за допомогою this

### 1. Витік конфіденційних даних через глобальні змінні
Ключ API зберігається у файлі JavaScript з URI https://victim.com/internal/api.js на веб-сайті жертви, žrtve.com, який доступний лише для автентифікованих користувачів. Зловмисник налаштовує веб-сайт, attackingwebsite.com, і використовує тег ```<script>``` для посилання на файл JavaScript.

Ось вміст https://victim.com/internal/api.js:
```
(function() {
  window.secret = "supersecretUserAPIkey";
})();
```
















