# Тестування обміну веб-повідомленнями

## Загальне

Обмін веб-повідомленнями (також відомі як обмін міждокументними повідомленнями) дозволяють програмам, які працюють у різних доменах, безпечно спілкуватися. До появи веб-повідомлень зв’язок різного походження (між фреймами iframe, вкладками та вікнами) обмежувався однаковою політикою джерела та запроваджувався браузером. Для виконання цих завдань розробники використовували кілька хаків, і більшість із них були переважно небезпечними.
Це обмеження в браузері діє, щоб запобігти зловмисному веб-сайту читати конфіденційні дані з інших iframe, вкладок тощо; однак існують законні випадки, коли два надійних веб-сайти повинні обмінюватися даними один з одним. Щоб задовольнити цю потребу, міждокументний обмін повідомленнями був представлений у проекті специфікації WHATWG HTML5 і реалізований у всіх основних браузерах. Це забезпечує безпечний зв’язок між кількома джерелами через iframe, вкладки та вікна.
API обміну повідомленнями представив метод postMessage(), за допомогою якого текстові повідомлення можна надсилати з різних джерел. Він складається з двох параметрів: повідомлення та домен.
Під час використання як домену існують деякі проблеми безпеки, які ми обговорюємо нижче. Щоб отримувати повідомлення, веб-сайт-одержувач має додати новий обробник подій, який має такі атрибути:

- Дані, зміст вхідного повідомлення;
- Походження документа відправника; і
- Джерело, вихідне вікно.

Ось приклад використовуваного API обміну повідомленнями:
'''
iframe1.contentWindow.postMessage("Hello world","http://www.example.com");
'''

Щоб отримати повідомлення:
```
window.addEventListener("message", handler, true);
function handler(event) {
    if(event.origin === 'chat.example.com') {
        /* process message (event.data) */
    } else {
        /* ignore messages from untrusted domains */
    }
}
```

### Безпека джерела
Початок складається зі схеми, імені хоста та порту. Він унікально ідентифікує домен, який надсилає або отримує повідомлення, і не включає шлях або фрагмент URL-адреси. Наприклад, https://example.com вважатиметься відмінним від http://example.com, оскільки схема першого – https, а другого – http. Це також стосується веб-серверів, які працюють в одному домені, але на різних портах.

## Цілі тестування
- Оцініть безпеку джерела повідомлення.
- Переконайтеся, що він використовує безпечні методи та перевіряє введені дані.

## Як тестувати

### Перевірте безпеку джерела
Тестери повинні перевірити, чи код програми фільтрує та обробляє повідомлення з довірених доменів. У межах домену відправника також переконайтеся, що домен отримувача вказано явно, і що * не використовується як другий аргумент postMessage(). Така практика може викликати занепокоєння щодо безпеки та може призвести до того, що у разі переспрямування або якщо джерело зміниться іншим способом, веб-сайт надсилає дані на невідомі хости, а отже, витік конфіденційних даних на шкідливі сервери.
Якщо на веб-сайті не вдається додати елементи керування безпекою для обмеження доменів або джерел, яким дозволено надсилати повідомлення на веб-сайт, це, ймовірно, створює ризик для безпеки. Тестери повинні перевірити код для прослуховувачів подій повідомлень і отримати функцію зворотного виклику з методу addEventListener для подальшого аналізу. Домени завжди мають бути перевірені перед маніпулюванням даними.

### Перевірте перевірку введених даних
Хоча теоретично веб-сайт приймає повідомлення лише від довірених доменів, дані все одно мають розглядатися як дані із зовнішніх джерел, які не є надійними, і оброблятися з відповідними засобами безпеки. Тестери повинні аналізувати код і шукати небезпечні методи, зокрема, коли дані оцінюються за допомогою eval() або вставляються в DOM через властивість innerHTML, що може створити XSS-уразливості на основі DOM.

### Статичний аналіз коду
Потрібно проаналізувати код JavaScript, щоб визначити, як реалізовано веб-повідомлення. Зокрема, тестерів має цікавити, як веб-сайт обмежує повідомлення з ненадійних доменів і як обробляються дані навіть для довірених доменів.
У цьому прикладі доступ потрібен для кожного субдомену (www, чат, форуми, …) у межах домену owasp.org. Код намагається прийняти будь-який домен із .owasp.org:
```
window.addEventListener("message", callback, true);

function callback(e) {
    if(e.origin.indexOf(".owasp.org")!=-1) {
        /* process message (e.data) */
    }
}
```

Намір полягає в тому, щоб дозволити такі субдомени, як:

- www.owasp.org
- chat.owasp.org
- forums.owasp.org

На жаль, це створює вразливі місця. Зловмисник може легко обійти фільтр, оскільки такий домен, як www.owasp.org.attacker.com, збігається.

Ось приклад коду, у якому відсутня перевірка походження. Це дуже небезпечно, оскільки прийматиме введення з будь-якого домену:
```
window.addEventListener("message", callback, true);

function callback(e) {
        /* process message (e.data) */
}
```

Ось приклад уразливості підтвердження введення, яка може призвести до атаки XSS:
```
window.addEventListener("message", callback, true);

function callback(e) {
        if(e.origin === "trusted.domain.com") {
            element.innerHTML= e.data;
        }
}
```
Більш безпечним підходом було б використання властивості innerText замість innerHTML.
Щоб отримати додаткові ресурси OWASP щодо веб-повідомлень, перегляньте шпаргалку безпеки OWASP HTML5
